package com.fit2081.warehouseinventoryapp.provider;

import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;

public class ItemContentProvider extends ContentProvider {
    // this provides other applications to be able to manipulate your database (delete, insert,
    // query, update, etc.).
    // do not implement methods if we do not want other applications to manipulate.

    ItemDatabase db;
    public static final String CONTENT_AUTHORITY="fit2081.app.DANIA";
    public static final Uri CONTENT_URI = Uri.parse("content://" + CONTENT_AUTHORITY);

    private static final int MULTIPLE_ROWS_TASKS = 1;
    private static final int SINGLE_ROW_TASKS = 2;

    private static final UriMatcher myMatcher = createUriMatcher();

    private static UriMatcher createUriMatcher() {
        // purpose: code will be able to know what is the type of the incoming Uri
        // classifies incoming uris into patterns associating each pattern to a unique match id
        // send it to a matcher which tells you the pattern of the incoming uri

        // create a new instance of UriMatcher
        final UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);

        uriMatcher.addURI(CONTENT_AUTHORITY, Item.TABLE_NAME, MULTIPLE_ROWS_TASKS);

        // "/#" tells us that table name is followed by a forward slash and then a number
        uriMatcher.addURI(CONTENT_AUTHORITY, Item.TABLE_NAME + "/#", SINGLE_ROW_TASKS);

        return uriMatcher;

    }

    public ItemContentProvider() {
    }

    @Override
    public boolean onCreate() {
        // provide access to SQLite database
        db = ItemDatabase.getDatabase(getContext());

        // return true to tell system content provider is ready
        return true;
    }

    @Override
    public String getType(Uri uri) {
        // tells application are we going to return single item or multiple items
        String returnType;

        int uriId = myMatcher.match(uri);
        switch (uriId) {
            case MULTIPLE_ROWS_TASKS:
                // type/subtype - standard MIME format
                // send you a set of items from table items
                returnType = "vnd.android.cursor.dir/items";
                break;
            case SINGLE_ROW_TASKS:
                returnType = "vnd.android.item/items";
                break;
            default:
                throw new UnsupportedOperationException("Not possible.");
        }

        return returnType;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection,
                        String[] selectionArgs, String sortOrder) {

        // Cursor holds multiple rows inside- an array of records in your database.
        Cursor cursor;

        // uri: maps to the table name, can provide extended uri to retrieve more specific data
        // projection: list of columns that should be retrieved for each throw
        // selection: constraint
        // selectionArgs: an array of arguments for selection constraint if you used '?'
        // sortOrder: sort results according to a certain column or not

        SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
        builder.setTables(Item.TABLE_NAME);
        String query = builder.buildQuery(projection, selection, null, null,
                sortOrder, null);
        // getOpenHelper() gives us the low level SQL database
        cursor = db
                .getOpenHelper()                // a library for android to access database
                .getReadableDatabase()          // specify that we just want to read data
                .query(query, selectionArgs);

        return cursor;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        // ContentValues does the mapping between the key and the values. It is a container. The
        // other application will provide the data to insert in this parameter. Cursor holds
        // multiple rows while ContentValues holds one row.

        Uri returnUri;

        // newId is the autogenerated id (remember we configured it so we it would auto-generate)
        long newId = db
                .getOpenHelper()
                .getWritableDatabase()      // specify that we want to modify database
                // conflict algorithm: tells SQLite how to behave if a constraint violation occurs
                // set to 0 so we will provide no action
                .insert(Item.TABLE_NAME, 0, values);

        // construct new unique uri of this inserted row
        // content://fit2081.app.db.DANIA/newId
        returnUri = ContentUris.withAppendedId(CONTENT_URI, newId);

        return returnUri;
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        // count represents the number of rows that will be deleted
        int count;

        count = db.getOpenHelper()
                .getWritableDatabase()
                .delete(Item.TABLE_NAME, selection, selectionArgs);

        // return the number of rows that have been deleted
        return count;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection,
                      String[] selectionArgs) {
        int count;

        // count is the number of rows that have been updated
        count = db
                .getOpenHelper()
                .getWritableDatabase()
                .update(Item.TABLE_NAME, 0, values, selection, selectionArgs);


        return count;
    }
}
